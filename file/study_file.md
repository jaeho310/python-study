# txt, pdf, pptx 파일이 저장되고 구분되는 원리

## 2진수와 16진수
```
컴퓨터는 반도체소자들의 집합체이며 각 소자들은 전류가 흐르면 1 흐르지 않으면 0을 표현합니다.(2진법사용)
즉 컴퓨터는 0과1을 모든것을 처리해야 하며 파일역시 0과1을 이용하여 저장됩니다.

하나의 0이나 1을 1bit라고 하며 이것이 8개가 모이면 1byte라고 합니다.
1111은 10진수로 15(1+2+4+8)이며 16진수으로 F입니다.
1byte(8bit) 11111111은 10진수로 255(1+2+4+8+16+32+64+128)이며 16진수로 FF(16*15+15)입니다. 

1byte의 내용을 확인하기 위해서는 11111111 총 8자리의 2진수를 써야하지만 16진수로는 단 2자리 FF만 사용하면 되므로
보통 16진수 2자리에 1byte를 표현합니다.

1byte는 8bit 
2진수로 1 ~ 11111111
10진수로 1 ~ 256
16진수로 1 ~ 0xFF
```

## UNICODE
- 유니코드는 인코딩방식이 아니라 모든 문자를 2bytes의 숫자로 매핑시키는 방식입니다.(65536개(2^16), 유니코드3.0부터 110만개 이상)
- 컴퓨터상에서 우리눈에 보이는 모든 문자,특수기호들은 모두 UNICODE에 매핑되어있습니다.
- 유니코드 여러가지로 표현하는 인코딩 방식이 존재합니다.(ASCII, UTF-8 등)

## 대표적인 문자 인코딩 종류
- ASCII
    - 7bit를 사용하여 영어,숫자,특수문자를 표현(2**7이므로 128까지)
    - A는 American의 약자로 영어를 위해 만들어진 문자입니다.
- ANSI
    - 8bit로 구성되어 256개의 문자를 표현합니다.
    - ANSI = ASCII + CodePage(1bit)
- UTF-8
    - 유니코드를 위한 가변 길이 문자 인코딩(한글은 3byte 영어는 1byte ASCII는 그대로)
    - ANSI의 단점을 보완한 방식입니다.

## char로 file을 직접 만들어 확인
- 1A를 txt파일에 입력하고 저장합니다.
- 아래의 명령어로 인코딩과 byte를 확인합니다.

```bash
# charset이 ASCII인것을 확인할 수 있습니다.
$ file -i [filename]
test.txt: text/plain; charset=us-ascii

# 3141 이 저장되었습니다.
# 31는 문자1을 41은 문자A를 나타내는 16진수입니다.
$ xxd [filename]
00000000: 3141                                     1A

# 1byte를 16진수 두자리로 보는게 싫고 
# 2진수로 보고싶다면(8개의 bit를 보고싶다면) -b 옵션을 입력합니다.
# 16진수의 
$ xxd -b [filename]
00000000: 00110001 01000001                                      1A
```

## int vs char
- int는 4byte char는 1byte로 사용됩니다.
- int로 2를 저장하면 4byte를 사용하고, char로 2를 저장하면 1byte를 사용합니다.
- 대신 char로 2+2를 하면 22가되고 int로 2+2를 하면 4가 됩니다.
- 메모리와 byte 관점으로 생각해보겠습니다.

## txt 파일이란?
- 바이너리파일을 ascii utf 등으로 인코딩, 디코딩하여 읽고 쓰는 파일
- 유니코드가 특정 방식으로 인코딩되어 바이너리로 저장되는 파일
- 파일을 열어줄때도 해당 byte에 맞는 인코딩을 선택해서 열어야 정상적으로 인식합니다.

## 다른파일들은?
- pdf, pptx, png, html 등의 파일은 filesignature(magic number)를 가지고있습니다.


output2 에는 {1,'A'}를 struct로 저장
output3 에는 {'A'}을 struct로 저장
```